<!DOCTYPE html>
<html>
<head>
    <title>HelFO Agent Demo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            background-color: white;
            padding: 2.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 800px;
            text-align: center;
        }
        textarea {
            resize: vertical;
            min-height: 120px;
        }
        #workflowLog {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            font-family: monospace;
            padding: 1rem;
            height: 400px;
            overflow-y: scroll;
            margin-top: 1.5rem;
            text-align: left;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<div class="container">
    <h1 class="text-3xl font-bold mb-6">HelFO Agent Workflow Demo</h1>

    <textarea id="soapInput" class="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter SOAP note here"></textarea>
    <br>
    <button id="submitBtn" onclick="initiateWorkflow()" class="mt-4 px-6 py-3 bg-blue-600 text-white font-bold rounded-full hover:bg-blue-700 transition duration-300 shadow-lg">Submit SOAP</button>

    <div id="workflowLog"></div>

    <!-- Container for dynamic answer input -->
    <div id="answerContainer" class="mt-4"></div>
</div>

<script>
    let sessionId = null;
    let ws = null;
    let currentServiceCode = null;

    function log(msg) {
        const logDiv = document.getElementById('workflowLog');
        const time = new Date().toISOString();
        logDiv.textContent += `[${time}] ${msg}\n`;
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    function initiateWorkflow() {
        const soapText = document.getElementById('soapInput').value;
        if (!soapText.trim()) {
            alert("Please enter a SOAP note first!");
            return;
        }

        document.getElementById('submitBtn').disabled = true;
        sessionId = crypto.randomUUID();
        log(`Generated session ID: ${sessionId}`);

        // Step 1: Establish WebSocket connection
        // This MUST be done first before sending the SOAP note.
        const wsUrl = `ws://${window.location.host}/ws/agentic-workflow/${sessionId}`;
        log(`Attempting to connect WebSocket: ${wsUrl}`);
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            log("‚úÖ WebSocket connection opened.");
            // Step 2: Send the initial SOAP note via a single HTTP POST request.
            // This happens only once, when the workflow starts.
            sendSoapRequest(soapText);
        };

        ws.onmessage = function(event) {
            log(`üì• WS message received: ${event.data}`);

            let msg;
            try {
                msg = JSON.parse(event.data);
            } catch (err) {
                log(`‚ùå Failed to parse WS message: ${err}`);
                return;
            }

            let eventType, payload;
            if (msg.event_type && msg.payload) {
                eventType = msg.event_type;
                payload = msg.payload;
            } else {
                // This handles the case where the payload is the root object, as seen in your logs.
                eventType = 'waiting_for_user';
                payload = msg;
            }

            log(`üîç Event type: ${eventType}`);
            log(`Payload: ${JSON.stringify(payload, null, 2)}`);

            if (eventType === 'waiting_for_user' && payload.question) {
                const container = document.getElementById('answerContainer');
                container.innerHTML = '';

                // Extract the missing terms from the question string
                const questionText = payload.question;
                const termsMatch = questionText.match(/please provide: (.*)/);
                const missingTerms = termsMatch ? termsMatch[1].split(', ').map(term => term.trim()) : [];

                currentServiceCode = payload.service_code;

                const label = document.createElement('div');
                label.textContent = questionText;
                label.className = "text-lg font-semibold mb-2";
                container.appendChild(label);

                // Create a div to hold multiple input fields
                const inputsDiv = document.createElement('div');
                inputsDiv.id = 'answerInputs';
                container.appendChild(inputsDiv);

                missingTerms.forEach(term => {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'flex items-center mt-2';

                    const termLabel = document.createElement('span');
                    termLabel.textContent = `${term}: `;
                    termLabel.className = 'mr-2 font-medium';

                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `userAnswer-${term}`;
                    input.className = "flex-grow p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500";
                    input.placeholder = `Enter details for ${term}`;

                    inputGroup.appendChild(termLabel);
                    inputGroup.appendChild(input);
                    inputsDiv.appendChild(inputGroup);
                });

                const btn = document.createElement('button');
                btn.textContent = 'Submit Answers';
                btn.className = "mt-4 px-4 py-2 bg-green-600 text-white font-bold rounded-full hover:bg-green-700 transition duration-300 shadow-lg";

                // CRITICAL FIX: The event handler for this button
                // ONLY sends a WebSocket message. It does NOT call fetch().
                btn.onclick = () => {
                    const answers = {};
                    let allAnswered = true;
                    missingTerms.forEach(term => {
                        const input = document.getElementById(`userAnswer-${term}`);
                        if (input.value.trim() === '') {
                            allAnswered = false;
                        }
                        answers[term] = input.value.trim();
                    });

                    if (!allAnswered) {
                        alert("Please provide an answer for all terms!");
                        return;
                    }

                    if (!currentServiceCode) {
                        log("‚ùå Error: Service code not received from agent.");
                        alert("Service code missing in backend payload!");
                        return;
                    }

                    // This payload is sent to the backend via the WebSocket.
                    const sendPayload = {
                        responses: [{
                            service_code: currentServiceCode,
                            answers: answers
                        }]
                    };

                    log(`üì§ Sending WS answer: ${JSON.stringify(sendPayload)}`);
                    ws.send(JSON.stringify(sendPayload));
                    container.innerHTML = ''; // Clear the input field for the next question
                };

                container.appendChild(btn);
            }
        };

        ws.onclose = (event) => {
            log(`üîå WebSocket closed (code: ${event.code}, reason: ${event.reason || "none"})`);
        };

        ws.onerror = (err) => {
            log(`‚ö†Ô∏è WebSocket error: ${err.message || err}`);
            console.error("WebSocket error event:", err);
        };
    }

    async function sendSoapRequest(soapText) {
        try {
            log("üì§ Sending SOAP request to server...");
            // This fetch() call is only made ONCE at the start of the workflow.
            const response = await fetch("/ws/submit_soap", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    soap_text: soapText,
                    session_id: sessionId
                })
            });

            if (!response.ok) {
                const err = await response.text();
                log(`‚ùå Failed to submit SOAP: ${err}`);
                document.getElementById('submitBtn').disabled = false;
                return;
            }

            const data = await response.json();
            log(`üì® Session started successfully: ${data.session_id}`);
            log(`ü§î Initial question: ${data.question || "None"}`);

        } catch (error) {
            log(`‚ùå Fetch error submitting SOAP: ${error}`);
            document.getElementById('submitBtn').disabled = false;
        }
    }
</script>

</body>
</html>

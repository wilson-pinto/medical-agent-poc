import google.generativeai as genai
from app.config import GEMINI_API_KEY
import json
import re
from app.utils.json_utils import safe_extract_json
from app.core.pii_analyzer import analyze_text, anonymize_text


if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)
    model = genai.GenerativeModel("gemini-1.5-flash")
else:
    model = None

def _clean_model_text(text: str) -> str:
    """
    Remove markdown/json fences and surrounding whitespace.
    """
    if text is None:
        return ""
    cleaned = re.sub(r"^```(?:json)?\s*|\s*```$", "", text.strip(), flags=re.MULTILINE)
    return cleaned.strip()


def get_best_code(query: str, candidates: list[dict]) -> list[dict]:

    if not model:
        return [{"code": "N/A", "reason": "Gemini API key missing."}]

    prompt = f"""
You are a medical expert assistant with deep clinical knowledge.

You are given:
1. A grouped clinical concept (from the patient's symptoms, findings, or context).
2. A list of candidate diagnosis codes with descriptions and similarity scores, generated by embeddings.

Your strict tasks:
- ✅ Evaluate ONLY the provided candidate diagnoses. Do not invent or add new codes.
- ✅ Select the ones that are clinically plausible for the concept.
- ✅ Exclude unrelated or unlikely ones. If none are relevant, return an empty list.
- ✅ Rank the selected diagnoses by clinical plausibility and similarity.
- ✅ For each selected diagnosis, explain briefly **why it is clinically relevant** to the concept.
     - The reason should mention the **clinical or pathophysiological connection** between the concept and the diagnosis.
     - Do **not** refer to model scores or similarity metrics (e.g., FAISS or cross-encoder).
     - Do **not** mention re-ranking or embeddings.
- ✅ Always include the grouped clinical concept in the output for traceability.

Output format:
Return a JSON object with the following structure:
{{
  "concept": "{query}",
  "diagnoses": [
    {{
      "code": "<ICD code from input>",
      "reason": "<clinical justification: why this diagnosis matches the concept>",
    }}
  ]
}}

Grouped clinical concept:
\"\"\"{query}\"\"\"

Candidate diagnoses:
{json.dumps(candidates, indent=2)}

Output only the JSON object.
"""
    response = model.generate_content(prompt)
    text = _clean_model_text(response.text)

    # Parse JSON from model response
    try:
        print(f"Text from Gemini: {text}")
        output_json = safe_extract_json(text)
        # Return list of {code, reason} from diagnoses
        results = [
            {"code": d["code"], "reason": d["reason"]}
            for d in output_json.get("diagnoses", [])
        ]
        return results
    except json.JSONDecodeError:
        # fallback if parsing fails
        return [{"code": "N/A", "reason": "Failed to parse model output."}]